// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target x86_64-apple-ios13.6-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name SoulverCore
import Foundation
import JavaScriptCore
@_exported import SoulverCore
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public struct Airport {
  public let name: Swift.String
  public let iata_code: Swift.String
}
extension SoulverCore.Airport : Swift.Codable, Swift.Hashable, Swift.Equatable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.Airport, b: SoulverCore.Airport) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct Timespan : Swift.Equatable {
  public let dateComponents: Foundation.DateComponents
  public static func == (a: SoulverCore.Timespan, b: SoulverCore.Timespan) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class VariableList : Swift.CustomDebugStringConvertible {
  convenience public init(variables: [SoulverCore.Variable])
  final public func provideDefinitionsForValuesWith(definitionBlock: (SoulverCore.RawExpression) -> SoulverCore.CalculationResult)
  final public func allVariables() -> [SoulverCore.Variable]
  final public func variablesExludingLineReferences() -> [SoulverCore.Variable]
  final public func singleWordVariables() -> [SoulverCore.Variable]
  final public func multiWordVariables(reverseSortByLength: Swift.Bool) -> [SoulverCore.Variable]
  final public func setVariable(_ variable: SoulverCore.Variable)
  final public func setVariables(_ variables: [SoulverCore.Variable])
  final public func clearVariable(withName name: Swift.String)
  final public subscript(variableName: SoulverCore.VariableName) -> SoulverCore.Variable? {
    get
    set
  }
  final public var count: Swift.Int {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var isNotEmpty: Swift.Bool {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
extension SoulverCore.VariableList : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: SoulverCore.VariableList, rhs: SoulverCore.VariableList) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public class ResultPercentageCalculator {
  public init(customization: SoulverCore.EngineCustomization)
  public func percentageOf(calculationResult: SoulverCore.CalculationResult, whole: SoulverCore.CalculationResult, percentageFormattingPreferences: SoulverCore.FormattingPreferences? = nil) -> SoulverCore.CalculationResult?
  public func percentageChange(start: SoulverCore.CalculationResult, end: SoulverCore.CalculationResult, percentageFormattingPreferences: SoulverCore.FormattingPreferences? = nil) -> SoulverCore.CalculationResult?
  @objc deinit
}
public enum TimezoneCodeCorrectionBehavior {
  case automatic
  case onlyNonSummerCodes
  case never
  public static func == (a: SoulverCore.TimezoneCodeCorrectionBehavior, b: SoulverCore.TimezoneCodeCorrectionBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Decimal {
  public var doubleValue: Swift.Double {
    get
  }
}
public struct GPSCoordinates : Swift.Equatable, Swift.Hashable {
  public let lat: Foundation.Decimal
  public let long: Foundation.Decimal
  public static func == (a: SoulverCore.GPSCoordinates, b: SoulverCore.GPSCoordinates) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias LineIndex = Swift.Int
@_hasMissingDesignatedInitializers final public class LineSheet : Swift.Codable {
  final public var copy: SoulverCore.LineSheet {
    get
  }
  final public subscript(index: SoulverCore.LineIndex) -> SoulverCore.Line {
    get
    set
  }
  required public init(from decoder: any Swift.Decoder) throws
  final public func encode(to encoder: any Swift.Encoder) throws
  final public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
extension SoulverCore.LineSheet : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: SoulverCore.LineSheet, rhs: SoulverCore.LineSheet) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.LineSheet {
  final public var text: Swift.String {
    get
  }
}
public struct Multiplier : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.Multiplier, b: SoulverCore.Multiplier) -> Swift.Bool
}
public struct Laptime : Swift.Equatable {
  public static func == (a: SoulverCore.Laptime, b: SoulverCore.Laptime) -> Swift.Bool
}
public typealias PrototypeExpression = Swift.String
public struct UnitRange {
  public let lowerBound: Foundation.Decimal
  public let upperBound: Foundation.Decimal
  public let unit: SoulverCore.SCUnit
}
public class ResultOperations {
  public init(customization: SoulverCore.EngineCustomization, formattingPreferences: SoulverCore.FormattingPreferences?)
  public func add(leftSide: SoulverCore.CalculationResult, rightSide: SoulverCore.CalculationResult) -> SoulverCore.CalculationResult?
  public func subtract(rightSide: SoulverCore.CalculationResult, from leftSide: SoulverCore.CalculationResult) -> SoulverCore.CalculationResult?
  public func negate(calculationResult: SoulverCore.CalculationResult) -> SoulverCore.CalculationResult?
  @objc deinit
}
public struct CommentingOptions : Swift.Hashable, Swift.Equatable {
  public var bracketComments: Swift.Bool
  public var quotationMarkComments: Swift.Bool
  public var slashComments: Swift.Bool
  public var labelComments: Swift.Bool
  public var hashTags: Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.CommentingOptions, b: SoulverCore.CommentingOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum FunctionIdentifier : Swift.String, Swift.CaseIterable, Swift.Codable, Swift.RawRepresentable {
  case halfOf
  case lesserOf
  case greaterOf
  case midpoint
  case proportionsFindNumerator
  case proportionsFindDenominator
  case remainder
  case dividedBy
  case isPrime
  case clamp
  case multipliedBy
  case makeRandomNumber
  case gcd
  case lcm
  case squareRoot
  case cubedRoot
  case nthRoot
  case nthLog
  case nthLogReversed
  case toNearestX
  case combination
  case permutation
  case reversedCombination
  case reversedPermutation
  case percentOf
  case percentOff
  case percentOn
  case isPercentOfWhat
  case isPercentOffWhat
  case isPercentOnWhat
  case isPercentOfWhatClassic
  case isPercentOffWhatClassic
  case isPercentOnWhatClassic
  case isWhatPercentOf
  case isWhatPercentOff
  case isWhatPercentOn
  case reversedPercentOf
  case reversedPercentOff
  case reversedPercentOn
  case isWhatMultiplierOf
  case isWhatMultiplierOn
  case isWhatMultiplierOff
  case salesTaxIn
  case exponentialGrowth
  case exponentialDecay
  case timeRequiredForExponentialChange
  case growthOverExponentialChange
  case timeRequiredForLinearChange
  case xToYIsWhatPercentage
  case xToYIsWhatMultiplier
  case xToY
  case timeInTimezone
  case dateInTimezone
  case differenceBetweenTimezones
  case generateTimestamp
  case calendarUnitBetweenDates
  case inclusiveCalendarUnitBetweenDates
  case intervalBetweenDates
  case inclusiveIntervalBetweenDates
  case calendarUnitToDate
  case calendarUnitSinceDate
  case calendarUnitInDate
  case calendarUnitLeftInDate
  case calendarUnitToDatespan
  case calendarUnitInDatespan
  case calendarUnitExpressionAgo
  case calendarUnitExpressionBeforeDate
  case calendarUnitExpressionAfterDate
  case halfwayBetweenDates
  case dayNumberOnDate
  case dayOfYear
  case weekdayAfterTimespan
  case dayOfWeekOnDate
  case weekNumberOnDate
  case weekOfYear
  case formFrametime
  case framesToFrametime
  case intervalBetweenTimestamps
  case intervalBetweenLaptimes
  case framesBetweenFrametimes
  case intervalBetweenFrametimes
  case unitConversion
  case unitInUnitExpression
  case calendarUnitInTimespan
  case rateUnitChange
  case rateForADuration
  case substanceWeightToVolumeConversion
  case densityOfSubstance
  case speedForTime
  case powerAtRotation
  case presentValue
  case returnOnInvestmentAfter
  case returnOnInvestment
  case totalInterestOnLoanRepayment
  case annualInterestOnLoanRepayment
  case monthlyInterestOnLoanRepayment
  case totalLoanRepayment
  case annualLoanRepayment
  case monthlyLoanRepayment
  case compoundInterest
  case compoundInterestCompoundingMonthly
  case compoundInterestCompoundingQuarterly
  case dollarWorthAdjustedForInflation
  case predictedDollarWorthGivenInflation
  case dollarWorthFromTodayAdjustedForInflation
  case dollarWorthToTodayAdjustedForInflation
  case gpsCoordinatesOfPlace
  case longitudeOfPlace
  case latitudeOfPlace
  case pixelsInLengthAtPPI
  case screenDensity
  case tyreSpeed
  case lowTemperature
  case highTemperature
  case precipitationChance
  case rainfallAmount
  case snowfallAmount
  case apparentTemperature
  case currentTemperature
  case weatherConditions
  case humidity
  case cloudCover
  case visibility
  case windDirection
  case windSpeed
  case dewPoint
  case uvIndex
  case pressureDirection
  case pressure
  case sunrise
  case sunset
  case moonrise
  case moonset
  case moonPhase
  case statisticOfList
  case statisticOfTag
  case countOfLiteral
  case extractLiteralPrefix
  case extractLiteralSuffix
  case parseLiteral
  case scrubNumberWithSpecifiedRange
  case declareGenericUnit
  public var returnType: SoulverCore.TokenType? {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.FunctionIdentifier]
  public typealias RawValue = Swift.String
  public static var allCases: [SoulverCore.FunctionIdentifier] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionCompletions {
  public class func completionsFor(textFragment: Swift.String, charIndex: Swift.Int, onLineAtIndex lineIndex: SoulverCore.LineIndex, in lineCollection: SoulverCore.LineCollection) -> [Swift.String]
  @objc deinit
}
public typealias Scalar = Swift.String
public struct Datestamp : Swift.Equatable {
  public enum DatestampType {
    case clockTime
    case utcTime
    case nakedDayOfMonth
    case nakedMonth
    case nakedYear
    case dayAndMonth
    case monthAndYear
    case dayMonthYear
    case dayMonthYearWithClockTimeDownToMinutes
    case dayMonthYearWithClockTimeDownToSeconds
    case dayMonthYearWithClockTimeDownToSubSeconds
    case dayMonthYearAndWeekday
    case weekDay
    case weekdayWithClockTime
    case relativeWeekday
    case now
    case today
    case tomorrow
    case yesterday
    case nextWeek
    case nextMonth
    case nextYear
    case lastWeek
    case lastYear
    case lastMonth
    case thisWeek
    case thisYear
    case thisMonth
    case quarter
    case unixTimestamp
    case iso8601
    case specialDay
    case unspecified
    public static func == (a: SoulverCore.Datestamp.DatestampType, b: SoulverCore.Datestamp.DatestampType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(date: Foundation.Date, type: SoulverCore.Datestamp.DatestampType, timezone: Foundation.TimeZone, hasExplicitTimeZone: Swift.Bool, isAmbiguous: Swift.Bool = false)
  public let date: Foundation.Date
  public var type: SoulverCore.Datestamp.DatestampType
  public var timezone: Foundation.TimeZone
  public let hasExplicitTimeZone: Swift.Bool
  public let isAmbiguous: Swift.Bool
  public static func == (a: SoulverCore.Datestamp, b: SoulverCore.Datestamp) -> Swift.Bool
}
public struct LineCollectionArchive : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class LineCollectionArchiver {
  public class func encode(lineCollection: SoulverCore.LineCollection) throws -> Foundation.Data
  public class func decode(encodedLineSheet: Foundation.Data, withCustomization customization: SoulverCore.EngineCustomization, preferredLocale locale: Foundation.Locale, defaultLineFormatting: SoulverCore.FormattingPreferences?, baseVariables: SoulverCore.VariableList?, evaluate: Swift.Bool = true) throws -> SoulverCore.LineCollection
  public class func archiveFor(lineCollection: SoulverCore.LineCollection) -> SoulverCore.LineCollectionArchive
  public class func lineCollectionFrom(archive: SoulverCore.LineCollectionArchive, withCustomization customization: SoulverCore.EngineCustomization, preferredLocale locale: Foundation.Locale) -> SoulverCore.LineCollection
  @objc deinit
}
public struct CustomUnit : Swift.Hashable, Swift.Equatable, Swift.Codable {
  public let name: Swift.String
  public let definition: Foundation.Decimal
  public let equivalentUnit: SoulverCore.UnitIdentifier
  public let legacyDefinition: Swift.String?
  public init(name: Swift.String, definition: Foundation.Decimal, equivalentUnit: SoulverCore.UnitIdentifier)
  public init(from decoder: any Swift.Decoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.CustomUnit, b: SoulverCore.CustomUnit) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
public struct Token {
  public let type: SoulverCore.TokenType
  public let subType: SoulverCore.TokenSubType
  public var stringValue: Swift.String
  public var range: Foundation.NSRange
  public var subtokens: SoulverCore.TokenList?
}
extension SoulverCore.Token : Swift.Equatable, Swift.Hashable, Swift.Comparable {
  public static func == (lhs: SoulverCore.Token, rhs: SoulverCore.Token) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func < (lhs: SoulverCore.Token, rhs: SoulverCore.Token) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.Token : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.Token {
  public var number: Foundation.Decimal? {
    get
  }
  public var scalar: SoulverCore.Scalar? {
    get
  }
  public var decimalValue: Foundation.Decimal {
    get
  }
  public var binaryValue: Swift.UInt? {
    get
  }
  public var hexValue: Swift.UInt? {
    get
  }
  public var octalValue: Swift.UInt? {
    get
  }
  public var resolutionValue: SoulverCore.Resolution? {
    get
  }
  public var salesTaxValue: SoulverCore.SalesTax? {
    get
  }
  public var percentageValue: SoulverCore.Percentage {
    get
  }
  public var unitExpressionValue: SoulverCore.UnitExpression? {
    get
  }
  public var unitValue: SoulverCore.SCUnit? {
    get
  }
  public var calendarComponentValue: Foundation.Calendar.Component? {
    get
  }
  public var unitRateValue: SoulverCore.UnitRate? {
    get
  }
  public var percentageRateValue: SoulverCore.PercentageRate? {
    get
  }
  public var decimalRateValue: SoulverCore.DecimalRate? {
    get
  }
  public var datestampValue: SoulverCore.Datestamp? {
    get
  }
  public var dmsValue: SoulverCore.DegreesMinutesSeconds? {
    get
  }
  public var datespanValue: SoulverCore.Datespan? {
    get
  }
  public var dateComponentsValue: Foundation.DateComponents? {
    get
  }
  public var placeValue: SoulverCore.Place? {
    get
  }
  public var gpsCoordinatesValue: SoulverCore.GPSCoordinates? {
    get
  }
  public var pitchValue: SoulverCore.Pitch? {
    get
  }
  public var timeZoneValue: Foundation.TimeZone? {
    get
  }
  public var fractionValue: SoulverCore.Fraction? {
    get
  }
  public var timespanValue: SoulverCore.Timespan? {
    get
  }
  public var dateIntervalValue: Foundation.DateInterval? {
    get
  }
  public var booleanValue: Swift.Bool {
    get
  }
  public var laptimeValue: SoulverCore.Laptime? {
    get
  }
  public var frametimeValue: SoulverCore.Frametime? {
    get
  }
  public var errorValue: SoulverCore.EvaluationError? {
    get
  }
  public var variable: SoulverCore.Variable? {
    get
  }
  public var statisticType: SoulverCore.StatisticType? {
    get
  }
  public var isLineReference: Swift.Bool {
    get
  }
  public var isVariable: Swift.Bool {
    get
  }
  public var functionIdentifier: SoulverCore.FunctionIdentifier? {
    get
  }
  public var functionName: Swift.String? {
    get
  }
  public var urlValue: Foundation.URL? {
    get
  }
  public var subsheetValue: SoulverCore.Subsheet? {
    get
  }
}
extension SoulverCore.DataPoint {
  public static var number: SoulverCore.DataPoint<SoulverCore.NumberFromTokenParser> {
    get
  }
  public static var binaryNumber: SoulverCore.DataPoint<SoulverCore.BinaryNumberFromTokenParser> {
    get
  }
  public static var octalNumber: SoulverCore.DataPoint<SoulverCore.OctalNumberFromTokenParser> {
    get
  }
  public static var hexNumber: SoulverCore.DataPoint<SoulverCore.HexNumberFromTokenParser> {
    get
  }
  public static var date: SoulverCore.DataPoint<SoulverCore.DateFromTokenParser> {
    get
  }
  public static var iso8601: SoulverCore.DataPoint<SoulverCore.iso8601FromTokenParser> {
    get
  }
  public static var unixTimestamp: SoulverCore.DataPoint<SoulverCore.UnixTimestampFromTokenParser> {
    get
  }
  public static var percentage: SoulverCore.DataPoint<SoulverCore.PercentageFromTokenParser> {
    get
  }
  public static var boolean: SoulverCore.DataPoint<SoulverCore.BooleanFromTokenParser> {
    get
  }
  public static var place: SoulverCore.DataPoint<SoulverCore.PlaceFromTokenParser> {
    get
  }
  public static var airport: SoulverCore.DataPoint<SoulverCore.AirportFromTokenParser> {
    get
  }
  public static var timeZone: SoulverCore.DataPoint<SoulverCore.TimeZoneFromTokenParser> {
    get
  }
  public static var currencyCode: SoulverCore.DataPoint<SoulverCore.CurrencyCodeFromTokenParser> {
    get
  }
  public static var currency: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var time: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var distance: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var temperature: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var weight: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var area: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var speed: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var volume: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fileSize: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fileTransferSpeed: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fuelEconomy: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fuelConsumption: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var pressure: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var frequency: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var power: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var angle: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static func unitOf(_ type: SoulverCore.UnitType) -> SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser>
  public static var timespan: SoulverCore.DataPoint<SoulverCore.TimespanFromTokenParser> {
    get
  }
  public static var laptime: SoulverCore.DataPoint<SoulverCore.LaptimeFromTokenParser> {
    get
  }
  public static var timecode: SoulverCore.DataPoint<SoulverCore.TimecodeFromTokenParser> {
    get
  }
  public static var url: SoulverCore.DataPoint<SoulverCore.URLFromTokenParser> {
    get
  }
  public static var emailAddress: SoulverCore.DataPoint<SoulverCore.EmailFromTokenParser> {
    get
  }
  public static var hashtag: SoulverCore.DataPoint<SoulverCore.HashtagFromTokenParser> {
    get
  }
  public static var whitespace: SoulverCore.DataPoint<SoulverCore.WhitespaceFromTokenParser> {
    get
  }
  public static var screenResolution: SoulverCore.DataPoint<SoulverCore.ScreenResolutionFromTokenParser> {
    get
  }
  public static var substance: SoulverCore.DataPoint<SoulverCore.SubstanceFromTokenParser> {
    get
  }
  public static var pitch: SoulverCore.DataPoint<SoulverCore.PitchFromTokenParser> {
    get
  }
}
public struct NumberFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Decimal
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.NumberFromTokenParser.DataType?
}
public struct BinaryNumberFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.UInt
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.UInt?
}
public struct OctalNumberFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.UInt
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.UInt?
}
public struct HexNumberFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.UInt
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.UInt?
}
public struct DateFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Date
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.DateFromTokenParser.DataType?
}
public struct PercentageFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Decimal
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.PercentageFromTokenParser.DataType?
}
public struct URLFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.URL
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.URLFromTokenParser.DataType?
}
public struct EmailFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.String
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.EmailFromTokenParser.DataType?
}
public struct WhitespaceFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.String
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.WhitespaceFromTokenParser.DataType?
}
public struct BooleanFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.Bool
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.Bool?
}
public struct PlaceFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Place
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Place?
}
public struct HashtagFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.String
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.String?
}
public struct SubstanceFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Substance
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Substance?
}
public struct AirportFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Place
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Place?
}
public struct TimeZoneFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Place
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Place?
}
public struct TimespanFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Timespan
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Timespan?
}
public struct LaptimeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Laptime
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Laptime?
}
public struct TimecodeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Frametime
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Frametime?
}
public struct CurrencyCodeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.CurrencyCode
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.CurrencyCode?
}
public struct UnitOfTypeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.UnitExpression
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.UnitExpression?
}
public struct ScreenResolutionFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Resolution
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Resolution?
}
public struct iso8601FromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Date
  public func parseDataFrom(token: SoulverCore.Token) -> Foundation.Date?
}
public struct UnixTimestampFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.TimeInterval
  public func parseDataFrom(token: SoulverCore.Token) -> Foundation.TimeInterval?
}
public struct PitchFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Pitch
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Pitch?
}
public struct Line : Swift.Codable, Swift.Identifiable {
  public enum CalculationBehaviour : Swift.String, Swift.Codable {
    case evaluatesExpression
    case sumsLinesAbove
    case definesFunction
    case tripWaypoint
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ExpressionAlignment : Swift.String, Swift.Codable {
    case left
    case center
    case right
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum HighlightColor : Swift.String, Swift.Codable, Swift.RawRepresentable {
    case red
    case orange
    case yellow
    case green
    case blue
    case purple
    case grey
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ApparentLineType {
    case regular
    case comment
    case header
    case variableDeclaration
    case divider
    case assertion
    public static func == (a: SoulverCore.Line.ApparentLineType, b: SoulverCore.Line.ApparentLineType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var expression: Swift.String
  public var behaviour: SoulverCore.Line.CalculationBehaviour
  public var skipStatistics: Swift.Bool
  public var lineReference: SoulverCore.LineReference?
  public var formattingPreferences: SoulverCore.FormattingPreferences?
  public var expressionAlignment: SoulverCore.Line.ExpressionAlignment
  public var highlight: SoulverCore.Line.HighlightColor?
  public var result: SoulverCore.CalculationResult?
  public var parsedExpression: SoulverCore.TokenList?
  public var apparentLineType: SoulverCore.Line.ApparentLineType?
  public var lineIndex: SoulverCore.LineIndex?
  public var variableEnvironment: SoulverCore.VariableList?
  public var id: Foundation.UUID {
    get
  }
  public var rawResult: Swift.String {
    get
  }
  public var formattedResult: Swift.String {
    get
  }
  public var attribution: Swift.String? {
    get
  }
  public init(_ expression: SoulverCore.RawExpression)
  public init()
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias ID = Foundation.UUID
}
extension SoulverCore.Line {
  public var isSubtotal: Swift.Bool {
    get
  }
  public var isWaypoint: Swift.Bool {
    get
  }
  public var isPartOfTrip: Swift.Bool {
    get
  }
  public var isHeading: Swift.Bool {
    get
  }
  public var isDivider: Swift.Bool {
    get
  }
}
extension SoulverCore.Line {
  public var declaredVariable: SoulverCore.Variable? {
    get
  }
  public func referencesInExpressionTo(variable: SoulverCore.Variable) -> [SoulverCore.Token]
  public var indexesReferencedInExpression: Foundation.IndexSet {
    get
  }
}
extension SoulverCore.Line : Swift.Equatable, Swift.Hashable {
  public static func == (a: SoulverCore.Line, b: SoulverCore.Line) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.Line : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public typealias PitchNotation = Swift.String
public struct Pitch : Swift.Equatable {
  public static func == (a: SoulverCore.Pitch, b: SoulverCore.Pitch) -> Swift.Bool
}
extension SoulverCore.DataPoint : _StringProcessing.CustomConsumingRegexComponent {
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: T.DataType)?
  public typealias RegexOutput = T.DataType
}
public struct Substance : Swift.Equatable {
  public let name: Swift.String
  public let value: Foundation.Decimal
  public var rateValue: SoulverCore.UnitRate {
    get
  }
  public static func == (a: SoulverCore.Substance, b: SoulverCore.Substance) -> Swift.Bool
}
public enum TokenType : Swift.CaseIterable {
  case number
  case `operator`
  case percentageSymbol
  case converterSymbol
  case unit
  case bracket
  case whitespace
  case variable
  case subsheet
  case equals
  case typeName
  case conditionalKeyword
  case conjunctionWord
  case prepositionWord
  case grammerArticleWord
  case functionName
  case javascriptFunctionName
  case timezone
  case degreesMinutesSeconds
  case gpsCoordinates
  case substance
  case comma
  case dot
  case quotationMark
  case colon
  case semicolon
  case hash
  case questionMark
  case label
  case fraction
  case binaryNumber
  case octalNumber
  case hexadecimalNumber
  case converter
  case unixTimestamp
  case datestamp
  case iso8601
  case timespan
  case laptime
  case frametime
  case datespan
  case dateWord
  case specialDay
  case pitch
  case dateQualifier
  case ordinalSuffix
  case relativePlaceWord
  case numberWord
  case statisticType
  case unitExpression
  case compoundUnitExpression
  case unitRange
  case conditionalExpression
  case percentage
  case salesTax
  case multiplier
  case dpSpecifier
  case resolution
  case list
  case boolean
  case rate
  case functionExpression
  case wordFunction
  case variableDeclaration
  case unitDeclaration
  case conditionalVariableDeclaration
  case declaredVariable
  case declaredUnit
  case variableAssignmentOperator
  case subexpression
  case wordComment
  case hashtag
  case bracketComment
  case slashComment
  case legacyQuotationComment
  case labelExpression
  case url
  case customType
  case error
  case pending
  case failed
  case remoteQuery
  case scalar
  case unidentified
  case customInternal
  case customUnit
  case dateComponents
  case literal
  case anyWord
  public static func == (a: SoulverCore.TokenType, b: SoulverCore.TokenType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SoulverCore.TokenType]
  public static var allCases: [SoulverCore.TokenType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public enum TokenSubType {
  case positiveNumber
  case negativeNumber
  case pi
  case tau
  case phi
  case additionOperator
  case subtractionOperator
  case multiplicationOperator
  case divisionOperator
  case reverseDivisionOperator
  case reverseSubtractionOperator
  case powerOperator
  case modOperator
  case lesserOf
  case greaterOf
  case greaterThan
  case greaterThanOrEqualTo
  case lessThan
  case lessThanOrEqualTo
  case equalTo
  case notEqualTo
  case logicalAndOperator
  case logicalOrOperator
  case logicalNotOperator
  case bitwiseAndOperator
  case bitwiseOrOperator
  case bitwiseXorOperator
  case bitwiseNotOperator
  case bitwiseLeftShiftOperator
  case bitwiseRightShiftOperator
  case squareRootSymbol
  case `false`
  case `true`
  case openBracket
  case closeBracket
  case converterSymbolTo
  case converterSymbolAs
  case converterSymbolIn
  case numberConverter
  case fractionConverter
  case multiplierConveter
  case scientificNotationConverter
  case binaryConverter
  case octalConverter
  case hexadecimalConverter
  case percentageConverter
  case percentageApplier
  case unitConverter
  case unitConverterWithExplicitRate
  case unitExpressionConverter
  case rateConverter
  case dateConverter
  case iso8601Converter
  case dateFormatTemplateConverter
  case feetAndInchesConverter
  case poundsAndOuncesConverter
  case timestampConverter
  case timespanConverter
  case yearsAndMonthsConverter
  case monthsAndWeeksConverter
  case monthsAndDaysConverter
  case weeksAndDaysConverter
  case daysAndHoursConverter
  case hoursAndMinutesConverter
  case laptimeConverter
  case frametimeConverter
  case pitchConverter
  case midiConverter
  case dmsConverter
  case frequencyRateConverter
  case timezoneConverter
  case roundingToDpConverter
  case roundingUpConverter
  case roundingConverter
  case roundingDownConverter
  case decimalRate
  case unitRate
  case percentageRate
  case dateWordToday
  case dateWordNow
  case dateWordTomorrow
  case dateWordYesterday
  case dateWordDayOfWeek
  case dateWordMonthOfYear
  case dateWordQuarterOfYear
  case dateWordAm
  case dateWordPm
  case dateWordMidday
  case dateWordMidnight
  case dateWordSummer
  case dateWordAutumn
  case dateWordWinter
  case dateWordSpring
  case dateQualifierNext
  case dateQualifierThis
  case dateQualifierPrevious
  case relativePlaceWordHere
  case statisticWordTotal
  case statisticWordAverage
  case statisticWordCount
  case statisticWordMedian
  case statisticWordLesser
  case statisticWordGreater
  case statisticWordLCM
  case statisticWordGCD
  case prepositionWordOf
  case prepositionWordAt
  case prepositionWordFor
  case prepositionWordFrom
  case prepositionWordSince
  case prepositionWordUntil
  case prepositionWordAfter
  case prepositionWordBefore
  case prepositionWordEarlier
  case prepositionWordLater
  case definiteGrammarArticleWord
  case indefiniteGrammarArticleWord
  case conjunctionWordAnd
  case conjunctionWordOr
  case numberTypeName
  case fractionTypeName
  case multiplierTypeName
  case scientificNotationTypeName
  case binaryTypeName
  case hexadecimalTypeName
  case octalTypeName
  case percentageTypeName
  case rateTypeName
  case timestampTypeName
  case timespanTypeName
  case feetAndInchesTypeName
  case poundsAndOuncesTypeName
  case laptimeTypeName
  case frametimeTypeName
  case dateTypeName
  case iso8601TypeName
  case decimalPlacesTypeName
  case midiTypeName
  case pitchTypeName
  case dmsTypeName
  case frequencyRateTypeName
  case yearsAndMonthsTypeName
  case monthsAndWeeksTypeName
  case monthsAndDaysTypeName
  case weeksAndDaysTypeName
  case daysAndHoursTypeName
  case hoursAndMinutesTypeName
  case minutesAndSecondsTypeName
  case builtInWordFunction
  case customWordFunction
  case conditionalKeywordIf
  case conditionalKeywordThen
  case conditionalKeywordElse
  case conditionalKeywordUnless
  case unitMismatchError
  case infinityError
  case divideByZeroError
  case imaginaryNumberError
  case unsupportedExponentOperationError
  case unsupportedUnitMultiplicationError
  case unsupportedRateError
  case badDivisionError
  case impreciseResultError
  case silentError
  case unknownError
  case notSpecified
  public static func == (a: SoulverCore.TokenSubType, b: SoulverCore.TokenSubType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct TokenTypeSet {
  public init(types: Swift.Set<SoulverCore.TokenType>)
  public let types: Swift.Set<SoulverCore.TokenType>
  public var count: Swift.Int {
    get
  }
  public func contains(_ tokenType: SoulverCore.TokenType) -> Swift.Bool
}
public typealias RawExpression = Swift.String
public struct CalculationResult : Swift.Equatable, Swift.Hashable {
  public init(evaluationResult: SoulverCore.EvaluationResult, stringValue: Swift.String, parsedExpression: SoulverCore.TokenList? = nil)
  public let stringValue: Swift.String
  public let evaluationResult: SoulverCore.EvaluationResult
  public let parsedExpression: SoulverCore.TokenList?
  public static func == (a: SoulverCore.CalculationResult, b: SoulverCore.CalculationResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.CalculationResult {
  public var isEmptyResult: Swift.Bool {
    get
  }
  public var isPendingResult: Swift.Bool {
    get
  }
  public var isFailedResult: Swift.Bool {
    get
  }
}
public var EmptyResult: SoulverCore.CalculationResult {
  get
}
public struct EngineFeatureFlags : Swift.Hashable, Swift.Equatable {
  public init()
  public var units: Swift.Bool
  public var calendarCalculations: Swift.Bool
  public var wordFunctions: Swift.Bool
  public var variableDeclarations: Swift.Bool
  public var disabledFunctions: Swift.Set<SoulverCore.FunctionIdentifier>?
  public var functionsRequireParentheses: Swift.Bool
  public var misplacedThousandsSeparatorBehavior: SoulverCore.MisplacedThousandsSeparatorBehavior
  public var timezoneCodeAutocorrectionBehavior: SoulverCore.TimezoneCodeCorrectionBehavior
  public var seeksFutureDate: Swift.Bool
  public var inAmbiguityPreferSomethingToNothing: Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.EngineFeatureFlags, b: SoulverCore.EngineFeatureFlags) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.EngineFeatureFlags {
  @available(*, deprecated, message: "Use `misplacedThousandsSeparatorBehavior = MisplacedThousandsSeparatorBehavior.allow` instead.")
  public var allowMisplacedThousandsSeparators: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use `timezoneCodeAutocorrectionBehavior = TimezoneCodeCorrectionBehavior.automatic` instead.")
  public var preferActiveTimeZoneAbbreviations: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use commentingOptions.hashTags on LineCollection")
  public var hashTags: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use commentingOptions.quotationMarkComments on LineCollection")
  public var quotationMarkComments: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use commentingOptions.bracketComments on LineCollection")
  public var bracketComments: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use commentingOptions.labelComments on LineCollection")
  public var labelComments: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use commentingOptions.slashComments on LineCollection")
  public var slashComments: Swift.Bool {
    get
    set
  }
}
extension SoulverCore.EngineFeatureFlags {
  public mutating func _limitToLegacyFeatureSet()
}
public let UntokenizedLineReference: Swift.String
public let LineAboveReference: Swift.String
@_hasMissingDesignatedInitializers public class SCUnit : Swift.Equatable, Swift.Hashable, Swift.CustomDebugStringConvertible {
  final public let identifier: SoulverCore.UnitIdentifier
  final public let symbol: Swift.String
  public var baseUnitValue: Foundation.Decimal {
    get
  }
  public var baseUnit: SoulverCore.SCUnit {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: SoulverCore.SCUnit, rhs: SoulverCore.SCUnit) -> Swift.Bool
  open class func baseUnit() -> SoulverCore.SCUnit
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.SCUnit {
  public var unitType: SoulverCore.UnitType {
    get
  }
}
public typealias UID = Swift.String
public struct LineReference : Swift.CustomStringConvertible {
  public let UID: SoulverCore.UID
  public init(UID: SoulverCore.UID)
  public var description: Swift.String {
    get
  }
}
extension SoulverCore.LineReference : Swift.Equatable, Swift.Codable, Swift.Hashable {
  public static func == (a: SoulverCore.LineReference, b: SoulverCore.LineReference) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct List {
  public let members: [SoulverCore.EvaluationResult]
}
public enum EvaluationError : Swift.Error {
  case UnitMismatch
  case UnsupportedUnitMultiplication
  case UnsupportedRate
  case UnsupportedExponentOperation
  case Infinity
  case ImaginaryNumber
  case DivideByZero
  case BadDivision
  case ImpreciseResult
  case SilentError
  case Other
  public static func == (a: SoulverCore.EvaluationError, b: SoulverCore.EvaluationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionExporter {
  public struct ExportOptions {
    public var plainTextSeparator: Swift.String
    public var useUnformattedResults: Swift.Bool
    public var substituteLineReferences: Swift.Bool
    public var includeAnswers: Swift.Bool
    public init()
  }
  public class func jsonDataFor(lineCollection: SoulverCore.LineCollection) -> Foundation.Data?
  public class func csvDataFor(lineCollection: SoulverCore.LineCollection, options: SoulverCore.LineCollectionExporter.ExportOptions) -> Foundation.Data?
  public class func textFor(lineCollection: SoulverCore.LineCollection, options: SoulverCore.LineCollectionExporter.ExportOptions = ExportOptions()) -> Swift.String
  @objc deinit
}
public struct DecimalRate : Swift.Equatable {
  public static func == (a: SoulverCore.DecimalRate, b: SoulverCore.DecimalRate) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class LineCollectionEnumerator {
  public typealias EnumerationExpression = Swift.String
  public typealias EnumerationResult = Swift.String
  public enum ReferenceSubstituionPolicy {
    case dontSubstitue
    case formattedResult
    case plainTextReference
    case markdownLinkStyle
    public static func == (a: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy, b: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ResultFormatting {
    case formatted
    case raw
    public static func == (a: SoulverCore.LineCollectionEnumerator.ResultFormatting, b: SoulverCore.LineCollectionEnumerator.ResultFormatting) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct LineCollectionEnumerationOptions {
    public var referenceSubstitutionPolicy: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy
    public var resultFormatting: SoulverCore.LineCollectionEnumerator.ResultFormatting
    public var reversed: Swift.Bool
    public init()
  }
  public typealias LineCollectionStringEnumerationHandler = ((SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult, inout Swift.Bool) -> Swift.Void)
  public typealias LineCollectionModelEnumerationHandler = ((SoulverCore.LineIndex, SoulverCore.TokenList, SoulverCore.CalculationResult?, inout Swift.Bool) -> Swift.Void)
  public class func enumerateStringsIn(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in handler: (SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult, inout Swift.Bool) -> Swift.Void)
  public class func enumerateModelsIn(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in modelHandler: (SoulverCore.LineIndex, SoulverCore.TokenList, SoulverCore.CalculationResult?, inout Swift.Bool) -> Swift.Void)
  public class func enumerateStringsIn<T>(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in handler: ((SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult) -> T?)) -> T?
  @objc deinit
}
public struct iso8601 : Swift.Equatable {
  public let datestamp: SoulverCore.Datestamp
  public static func == (a: SoulverCore.iso8601, b: SoulverCore.iso8601) -> Swift.Bool
}
public enum UnitType : Swift.String, Swift.CaseIterable, Swift.Codable {
  case acceleration
  case amountOfSubstance
  case angle
  case angularVelocity
  case area
  case concentrationMass
  case currency
  case dataStorage
  case dataTransfer
  case dispersion
  case duration
  case electricCharge
  case electricCurrent
  case electricPotential
  case electricResistance
  case electricConductance
  case electricalInductance
  case electricalCapacitance
  case magneticFlux
  case magneticFluxDensity
  case energy
  case force
  case frameRate
  case frames
  case frequency
  case fuelConsumption
  case fuelEconomy
  case illuminance
  case length
  case mass
  case other
  case period
  case power
  case pressure
  case screenDensity
  case speed
  case substanceConcentraion
  case temperature
  case torque
  case volume
  public var label: Swift.String {
    get
  }
  public var baseUnitIdentifier: SoulverCore.UnitIdentifier {
    get
  }
  public var associatedOtherUnits: [SoulverCore.UnitIdentifier] {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.UnitType]
  public typealias RawValue = Swift.String
  public static var allCases: [SoulverCore.UnitType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum UnitIdentifier : Swift.String, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable {
  case degrees
  case arcMinutes
  case arcSeconds
  case radians
  case gradians
  case revolutions
  case squareMegameters
  case squareKilometers
  case squareMeters
  case squareCentimeters
  case squareDecimeters
  case squareMillimeters
  case squareMicrometers
  case squareNanometers
  case squareInches
  case squareFeet
  case squareYards
  case squareMiles
  case acres
  case ares
  case hectares
  case litersPerKilometer
  case litersPer100Kilometers
  case milesPerImperialGallon
  case milesPerGallon
  case gramsPerLiter
  case kilometersPerLiter
  case seconds
  case minutes
  case hours
  case days
  case weekdays
  case nights
  case weeks
  case months
  case years
  case picoseconds
  case nanoseconds
  case microseconds
  case milliseconds
  case joules
  case kilojoules
  case megajoules
  case gigajoules
  case kilocalories
  case calories
  case wattSeconds
  case wattMinutes
  case wattHours
  case kilowattHours
  case megawattHours
  case gigawattHours
  case terawattHours
  case terahertz
  case gigahertz
  case megahertz
  case kilohertz
  case hertz
  case millihertz
  case microhertz
  case nanohertz
  case framesPerSecond
  case radiansPerSecond
  case revolutionsPerSecond
  case revolutionsPerMinute
  case megameters
  case hectokilometers
  case kilometers
  case hectometers
  case decameters
  case meters
  case decimeters
  case centimeters
  case millimeters
  case micrometers
  case nanometers
  case picometers
  case inches
  case feet
  case yards
  case miles
  case scandinavianMiles
  case lightyears
  case astronomicalUnits
  case nauticalMiles
  case fathoms
  case furlongs
  case parsecs
  case cycles
  case lux
  case kilograms
  case grams
  case decigrams
  case centigrams
  case milligrams
  case micrograms
  case nanograms
  case picograms
  case ounces
  case pounds
  case stones
  case metricTons
  case shortTons
  case carats
  case ouncesTroy
  case slugs
  case terawatts
  case gigawatts
  case megawatts
  case kilowatts
  case watts
  case milliwatts
  case microwatts
  case nanowatts
  case picowatts
  case femtowatts
  case horsepower
  case pascals
  case gigapascals
  case megapascals
  case kilopascals
  case hectopascals
  case inchesOfMercury
  case atmospheres
  case bars
  case millibars
  case millimetersOfMercury
  case poundsForcePerSquareInch
  case kilopoundsForcePerSquareInch
  case megapoundsForcePerSquareInch
  case metersPerSecond
  case feetPerSecond
  case kilometersPerHour
  case milesPerHour
  case knots
  case kelvin
  case celsius
  case fahrenheit
  case liters
  case kiloliters
  case megaliters
  case milliliters
  case microliters
  case nanoliters
  case centiliters
  case deciliters
  case cubicKilometers
  case cubicMeters
  case cubicDecimeters
  case cubicCentimeters
  case cubicMillimeters
  case cubicNanometers
  case cubicInches
  case cubicFeet
  case cubicYards
  case cubicMiles
  case acreFeet
  case bushels
  case teaspoons
  case tablespoons
  case fluidOunces
  case cups
  case pints
  case quarts
  case gallons
  case imperialTeaspoons
  case imperialTablespoons
  case imperialFluidOunces
  case imperialPints
  case imperialQuarts
  case imperialGallons
  case metricCups
  case metricTeaspoons
  case metricTablespoons
  case metricAUTablespoons
  case ppi
  case pixel
  case em
  case rem
  case point
  case frames
  case milligramsPerDeciliter
  case partsPerMillion
  case moles
  case millimoles
  case micromoles
  case nanomoles
  case molar
  case newtons
  case kilonewtons
  case meganewtons
  case giganewtons
  case millinewtons
  case micronewtons
  case nanonewtons
  case poundals
  case poundsOfForce
  case ouncesOfForce
  case newtonMeters
  case poundFeet
  case poundInches
  case ounceInches
  case metersPerSecondSquared
  case feetPerSecondSquared
  case gravity
  case coulombs
  case megaampereHours
  case kiloampereHours
  case ampereHours
  case milliampereHours
  case microampereHours
  case megaamperes
  case kiloamperes
  case amperes
  case milliamperes
  case microamperes
  case megavolts
  case kilovolts
  case volts
  case millivolts
  case microvolts
  case megaohms
  case kiloohms
  case ohms
  case milliohms
  case microohms
  case siemens
  case kilosiemens
  case megasiemens
  case millisiemens
  case microsiemens
  case henrys
  case kilohenrys
  case megahenrys
  case millihenrys
  case microhenrys
  case farads
  case kilofarads
  case megafarads
  case millifarads
  case microfarads
  case webers
  case kilowebers
  case megawebers
  case milliwebers
  case microwebers
  case teslas
  case kiloteslas
  case megateslas
  case milliteslas
  case microteslas
  case bytes
  case bits
  case nibbles
  case yottabytes
  case zettabytes
  case exabytes
  case petabytes
  case terabytes
  case gigabytes
  case megabytes
  case kilobytes
  case yottabits
  case zettabits
  case exabits
  case petabits
  case terabits
  case gigabits
  case megabits
  case kilobits
  case yobibytes
  case zebibytes
  case exbibytes
  case pebibytes
  case tebibytes
  case gibibytes
  case mebibytes
  case kibibytes
  case yobibits
  case zebibits
  case exbibits
  case pebibits
  case tebibits
  case gibibits
  case mebibits
  case kibibits
  case bytesPerSecond
  case bitsPerSecond
  case yottabytesPerSecond
  case zettabytesPerSecond
  case exabytesPerSecond
  case petabytesPerSecond
  case terabytesPerSecond
  case gigabytesPerSecond
  case megabytesPerSecond
  case kilobytesPerSecond
  case yottabitsPerSecond
  case zettabitsPerSecond
  case exabitsPerSecond
  case petabitsPerSecond
  case terabitsPerSecond
  case gigabitsPerSecond
  case megabitsPerSecond
  case kilobitsPerSecond
  case yobibytesPerSecond
  case zebibytesPerSecond
  case exbibytesPerSecond
  case pebibytesPerSecond
  case tebibytesPerSecond
  case gibibytesPerSecond
  case mebibytesPerSecond
  case kibibytesPerSecond
  case yobibitsPerSecond
  case zebibitsPerSecond
  case exbibitsPerSecond
  case pebibitsPerSecond
  case tebibitsPerSecond
  case gibibitsPerSecond
  case mebibitsPerSecond
  case kibibitsPerSecond
  case currencyADA
  case currencyAED
  case currencyAFN
  case currencyALL
  case currencyAMD
  case currencyANG
  case currencyAOA
  case currencyARS
  case currencyAUD
  case currencyAWG
  case currencyAZN
  case currencyBAM
  case currencyBBD
  case currencyBCH
  case currencyBDT
  case currencyBGN
  case currencyBHD
  case currencyBIF
  case currencyBMD
  case currencyBNB
  case currencyBND
  case currencyBOB
  case currencyBRL
  case currencyBSD
  case currencyBSV
  case currencyBTC
  case currencyBTN
  case currencyBWP
  case currencyBYN
  case currencyBZD
  case currencyCAD
  case currencyCDF
  case currencyCHF
  case currencyCLF
  case currencyCLP
  case currencyCNY
  case currencyCOP
  case currencyCRC
  case currencyCUC
  case currencyCVE
  case currencyCZK
  case currencyDASH
  case currencyDJF
  case currencyDKK
  case currencyDOGE
  case currencyDOP
  case currencyDZD
  case currencyEGP
  case currencyEOS
  case currencyERN
  case currencyETB
  case currencyETC
  case currencyETH
  case currencyEUR
  case currencyFJD
  case currencyFKP
  case currencyGBP
  case currencyGEL
  case currencyGGP
  case currencyGHS
  case currencyGIP
  case currencyGMD
  case currencyGNF
  case currencyGTQ
  case currencyGYD
  case currencyHKD
  case currencyHNL
  case currencyHRK
  case currencyHTG
  case currencyHUF
  case currencyIDR
  case currencyILS
  case currencyIMP
  case currencyINR
  case currencyIQD
  case currencyIRR
  case currencyISK
  case currencyJEP
  case currencyJMD
  case currencyJOD
  case currencyJPY
  case currencyKES
  case currencyKGS
  case currencyKHR
  case currencyKMF
  case currencyKPW
  case currencyKRW
  case currencyKWD
  case currencyKYD
  case currencyKZT
  case currencyLAK
  case currencyLBP
  case currencyLKR
  case currencyLRD
  case currencyLSL
  case currencyLTC
  case currencyLTL
  case currencyLVL
  case currencyLYD
  case currencyMAD
  case currencyMDL
  case currencyMGA
  case currencyMKD
  case currencyMMK
  case currencyMNT
  case currencyMOP
  case currencyMRO
  case currencyMUR
  case currencyMVR
  case currencyMWK
  case currencyMXN
  case currencyMYR
  case currencyMZN
  case currencyNAD
  case currencyNEO
  case currencyNGN
  case currencyNIO
  case currencyNOK
  case currencyNPR
  case currencyNZD
  case currencyOMR
  case currencyPAB
  case currencyPEN
  case currencyPGK
  case currencyPHP
  case currencyPKR
  case currencyPLN
  case currencyPYG
  case currencyQAR
  case currencyRON
  case currencyRSD
  case currencyRUB
  case currencyRWF
  case currencySAR
  case currencySBD
  case currencySCR
  case currencySDG
  case currencySEK
  case currencySGD
  case currencySHP
  case currencySLL
  case currencySOS
  case currencySOL
  case currencyAVAX
  case currencyLUNA
  case currencyDOT
  case currencyMATIC
  case currencySHIB
  case currencySRD
  case currencySTD
  case currencySVC
  case currencySYP
  case currencySZL
  case currencyTHB
  case currencyTJS
  case currencyTMT
  case currencyTND
  case currencyTOP
  case currencyTRX
  case currencyTRY
  case currencyTTD
  case currencyTWD
  case currencyTZS
  case currencyUAH
  case currencyUGX
  case currencyUSD
  case currencyUSDT
  case currencyUYU
  case currencyUZS
  case currencyVEF
  case currencyVND
  case currencyVUV
  case currencyWST
  case currencyXAF
  case currencyXAG
  case currencyXAU
  case currencyXCD
  case currencyXDR
  case currencyXLM
  case currencyXMR
  case currencyXOF
  case currencyXPF
  case currencyXRP
  case currencyYER
  case currencyZAR
  case currencyZMK
  case currencyZMW
  case currencyZWL
  case currencySatoshi
  case currencyDollarCents
  case currencyBritishPence
  case currencyEuroCents
  case undefined
  public var unit: SoulverCore.SCUnit {
    get
  }
  public var unitType: SoulverCore.UnitType {
    get
  }
  public var motherUnitIdentifier: SoulverCore.UnitIdentifier {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.UnitIdentifier]
  public typealias RawValue = Swift.String
  public static var allCases: [SoulverCore.UnitIdentifier] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class ResultContextualMetadata {
  public class func humanReadableMetadataFor(formattedResult: SoulverCore.CalculationResult, customization: SoulverCore.EngineCustomization) -> Swift.String?
  @objc deinit
}
public enum StatisticType : Swift.Int, Swift.RawRepresentable, Swift.CaseIterable, Swift.Equatable {
  case total
  case average
  case count
  case median
  case lesser
  case greater
  case lcm
  case gcd
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [SoulverCore.StatisticType]
  public typealias RawValue = Swift.Int
  public static var allCases: [SoulverCore.StatisticType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public struct LineSheetDelta {
  public let indexesAdded: Foundation.IndexSet
  public let indexesDeleted: Foundation.IndexSet
  public let indexesModified: Foundation.IndexSet
  public var isSingleLineEdit: Swift.Bool {
    get
  }
}
extension Foundation._NSRange {
  public static var zero: Foundation.NSRange {
    get
  }
}
public typealias TokenIndex = Swift.Int
public struct TokenIndexPath : Swift.Equatable {
  public init(tokenIndex: SoulverCore.TokenIndex, lineIndex: SoulverCore.LineIndex)
  public let tokenIndex: SoulverCore.TokenIndex
  public let lineIndex: SoulverCore.LineIndex
  public static func == (a: SoulverCore.TokenIndexPath, b: SoulverCore.TokenIndexPath) -> Swift.Bool
}
public typealias CurrencyCode = Swift.String
@_hasMissingDesignatedInitializers public class CurrencyList : SoulverCore.CurrencyRateProvider {
  public func rateFor(request: SoulverCore.CurrencyRateRequest) -> Foundation.Decimal?
  public static let realWorldCurrencies: Swift.Set<SoulverCore.UnitIdentifier>
  public static let cryptoCurrencies: Swift.Set<SoulverCore.UnitIdentifier>
  public static let commodities: Swift.Set<SoulverCore.UnitIdentifier>
  public static let fractionalCurrencies: Swift.Set<SoulverCore.UnitIdentifier>
  public class func unitIdentifierFor(code: SoulverCore.CurrencyCode) -> SoulverCore.UnitIdentifier?
  public class func currencyCodeFor(unitIdentifier: SoulverCore.UnitIdentifier) -> SoulverCore.CurrencyCode?
  @objc deinit
}
public struct Subsheet : Swift.Hashable, Swift.Equatable, Swift.Codable {
  public enum SubsheetEvaluatorType : Swift.String, Swift.Codable {
    case soulverCore
    case javascript
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let lineSheet: SoulverCore.LineSheet
  public let identifier: SoulverCore.LineReference
  public let evaluator: SoulverCore.Subsheet.SubsheetEvaluatorType
  public var canReferenceVariablesOutsideBody: Swift.Bool
  public static func == (lhs: SoulverCore.Subsheet, rhs: SoulverCore.Subsheet) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.Subsheet {
  public var stringValue: Swift.String {
    get
  }
}
public enum SIThreshold : Swift.String {
  case pentillion
  case septillion
  case sextillion
  case quintillion
  case quadrillion
  case trillion
  case billion
  case million
  case hundredThousand
  case thousand
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
indirect public enum EvaluationResult {
  case rawString(Swift.String)
  case decimal(Foundation.Decimal)
  case percentage(SoulverCore.Percentage)
  case fraction(SoulverCore.Fraction)
  case scientificNotation(Foundation.Decimal)
  case binary(Swift.UInt)
  case octal(Swift.UInt)
  case hex(Swift.UInt)
  case multiplier(SoulverCore.Multiplier)
  case boolean(Swift.Bool)
  case unitExpression(SoulverCore.UnitExpression)
  case decimalRate(SoulverCore.DecimalRate)
  case unitRate(SoulverCore.UnitRate)
  case percentageRate(SoulverCore.PercentageRate)
  case unitRange(SoulverCore.UnitRange)
  case date(SoulverCore.Datestamp)
  case datespan(SoulverCore.Datespan)
  case iso8601(SoulverCore.iso8601)
  case timestamp(SoulverCore.Timestamp)
  case timespan(SoulverCore.Timespan)
  case laptime(SoulverCore.Laptime)
  case frametime(SoulverCore.Frametime)
  case gpsCoordinates(SoulverCore.GPSCoordinates)
  case degreesMinutesSeconds(SoulverCore.DegreesMinutesSeconds)
  case resolution(SoulverCore.Resolution)
  case salesTax(SoulverCore.SalesTax)
  case pitch(SoulverCore.Pitch)
  case unit(SoulverCore.SCUnit)
  case substance(SoulverCore.Substance)
  case place(SoulverCore.Place)
  case customType(SoulverCore.CustomType)
  case statisticType(SoulverCore.StatisticType)
  case list(SoulverCore.List)
  case error(SoulverCore.EvaluationError)
  case variable(SoulverCore.Variable)
  case customUnit(SoulverCore.CustomUnit)
  case pending
  case failed
  case none
  public var stringValue: Swift.String? {
    get
  }
  public var equivalentTokenType: SoulverCore.TokenType {
    get
  }
  public var decimalValue: Foundation.Decimal? {
    get
  }
  public var unitExpressionValue: SoulverCore.UnitExpression? {
    get
  }
  public var rateValue: SoulverCore.UnitRate? {
    get
  }
  public var booleanValue: Swift.Bool? {
    get
  }
  public var unitRangeValue: SoulverCore.UnitRange? {
    get
  }
  public var datestampValue: SoulverCore.Datestamp? {
    get
  }
  public var placeValue: SoulverCore.Place? {
    get
  }
  public var timespanValue: SoulverCore.Timespan? {
    get
  }
  public var unitValue: SoulverCore.SCUnit? {
    get
  }
  public var substanceValue: SoulverCore.Substance? {
    get
  }
  public var gpsCoordinatesValue: SoulverCore.GPSCoordinates? {
    get
  }
  public var dmsValue: SoulverCore.DegreesMinutesSeconds? {
    get
  }
  public var variableValue: SoulverCore.Variable? {
    get
  }
}
extension SoulverCore.EvaluationResult : Swift.Equatable {
  public static func == (lhs: SoulverCore.EvaluationResult, rhs: SoulverCore.EvaluationResult) -> Swift.Bool
}
extension SoulverCore.EvaluationResult : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Datespan : Swift.Equatable {
  public let startDate: Foundation.Date
  public let endDate: Foundation.Date
  public var dateIntervalValue: Foundation.DateInterval {
    get
  }
  public static func == (a: SoulverCore.Datespan, b: SoulverCore.Datespan) -> Swift.Bool
}
public struct CustomFunction {
  public init(prototypeExpression: SoulverCore.PrototypeExpression, handler: @escaping SoulverCore.CustomFunctionHandler)
  public var backgroundHandler: SoulverCore.BackgroundCustomFunctionHandler?
  public var customTypes: [SoulverCore.CustomType]?
  public var aliases: [SoulverCore.PrototypeExpression]?
  public var prerequisiteTypes: SoulverCore.TokenTypeSet?
  public var identifier: Swift.String?
}
extension SoulverCore.CustomFunction : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SoulverCore.CustomFunction, rhs: SoulverCore.CustomFunction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias CustomFunctionHandler = (_ parameters: [SoulverCore.EvaluationResult]) -> SoulverCore.EvaluationResult
#if compiler(>=5.3) && $AsyncAwait
public typealias BackgroundCustomFunctionHandler = (_ parameters: [SoulverCore.EvaluationResult]) async throws -> SoulverCore.EvaluationResult
#endif
public typealias PrototypePlaceholder = Swift.String
public struct CustomType {
  public init(prototypePlaceholder: SoulverCore.PrototypePlaceholder, symbols: [Swift.String], associatedObject: Any?)
  public let prototypePlaceholder: SoulverCore.PrototypePlaceholder
  public let symbols: [Swift.String]
  public let associatedObject: Any?
}
extension SoulverCore.CustomType : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SoulverCore.CustomType, rhs: SoulverCore.CustomType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.String {
  public var isSingleWord: Swift.Bool {
    get
  }
  public var isPhrase: Swift.Bool {
    get
  }
}
public enum TokenListForm : Swift.Equatable {
  case singleNumber(value: Foundation.Decimal)
  case singleUnitExpression(value: SoulverCore.UnitExpression)
  case singleDatestamp(value: SoulverCore.Datestamp)
  case conversion(fromUnit: SoulverCore.SCUnit, toUnit: SoulverCore.SCUnit, quantity: Foundation.Decimal)
  case dateSeeking(startDate: SoulverCore.Datestamp, timespan: SoulverCore.Timespan, direction: Foundation.Calendar.SearchDirection)
  case unitUntilDateSeeking(unit: SoulverCore.SCUnit, toDate: SoulverCore.Datestamp)
  case intervalBetweenDatesSeeking(startDate: SoulverCore.Datestamp, endDate: SoulverCore.Datestamp, unit: SoulverCore.SCUnit?)
  case timeAtPlaceSeeking(place: SoulverCore.Place)
  case timeDifferenceBetweenPlacesSeeking(firstPlace: SoulverCore.Place, secondPlace: SoulverCore.Place)
  case timeConversionToPlace(fromDate: SoulverCore.Datestamp, toPlace: SoulverCore.Place)
  case customFunction(function: SoulverCore.CustomFunction, parameters: [SoulverCore.EvaluationResult])
  case other
  public static func == (a: SoulverCore.TokenListForm, b: SoulverCore.TokenListForm) -> Swift.Bool
}
public struct TokenListMetadata {
  public let form: SoulverCore.TokenListForm
}
extension SoulverCore.TokenList {
  final public var metadata: SoulverCore.TokenListMetadata {
    get
  }
}
final public class Calculator {
  final public var customization: SoulverCore.EngineCustomization {
    get
  }
  public init(customization: SoulverCore.EngineCustomization)
  final public func calculate(_ expression: SoulverCore.RawExpression, with variableList: SoulverCore.VariableList? = nil) -> SoulverCore.CalculationResult
  #if compiler(>=5.3) && $AsyncAwait
  final public func calculateInBackground(_ expression: SoulverCore.RawExpression, with variableList: SoulverCore.VariableList? = nil) async -> SoulverCore.CalculationResult
  #endif
  final public var formattingPreferences: SoulverCore.FormattingPreferences?
  @objc deinit
}
extension SoulverCore.Calculator {
  public static var basic: SoulverCore.Calculator {
    get
  }
  final public func dateFor(_ expression: Swift.String, with variableList: SoulverCore.VariableList? = nil) -> (date: Foundation.Date, result: SoulverCore.CalculationResult)?
  final public class func functionParametersIn(_ expression: Swift.String, matching prototypeExpressions: [SoulverCore.PrototypeExpression], customization: SoulverCore.EngineCustomization = .standard) -> [SoulverCore.EvaluationResult]?
}
extension Swift.Collection where Self.Element == Swift.String {
  public func find<T>(_ find: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current) -> [T.DataType] where T : SoulverCore.DataFromTokenParser
  public func find<T, U>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, locale: Foundation.Locale = .current) -> [(T.DataType, U.DataType)] where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser
  public func find<T, U, Y>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<Y>, locale: Foundation.Locale = .current) -> [(T.DataType, U.DataType, Y.DataType)] where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, Y : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, locale: Foundation.Locale = .current) -> [(T.DataType, U.DataType, V.DataType, W.DataType)] where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W, X>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, _ entity5: SoulverCore.DataPoint<X>, locale: Foundation.Locale = .current) -> [(T.DataType, U.DataType, V.DataType, W.DataType, X.DataType)] where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser, X : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W, X, Y>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, _ entity5: SoulverCore.DataPoint<X>, _ entity6: SoulverCore.DataPoint<Y>, locale: Foundation.Locale = .current) -> [(T.DataType, U.DataType, V.DataType, W.DataType, X.DataType, Y.DataType)] where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser, X : SoulverCore.DataFromTokenParser, Y : SoulverCore.DataFromTokenParser
}
extension Swift.Collection where Self.Element == Swift.String {
  public func replacingAll<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: ((T.DataType) -> Swift.String?)) -> [Swift.String] where T : SoulverCore.DataFromTokenParser
  public func replacingFirst<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: ((T.DataType) -> Swift.String?)) -> [Swift.String] where T : SoulverCore.DataFromTokenParser
}
public class LineCollectionReducer {
  public var inflectCustomUnits: Swift.Bool
  public init(lineCollection: SoulverCore.LineCollection)
  public var returnValue: SoulverCore.CalculationResult {
    get
  }
  public var locallyDefinedVariables: [SoulverCore.Variable] {
    get
  }
  public var locallyDefinedUnits: [SoulverCore.CustomUnit] {
    get
  }
  public struct CustomDefinitions {
    public let customVariables: [SoulverCore.Variable]
    public let customUnits: [SoulverCore.CustomUnit]
    public let inflectedCustomUnits: [SoulverCore.CustomUnit]
    public let customPlaces: [SoulverCore.Place]
    public let customFunctions: [SoulverCore.CustomFunction]
  }
  public var customDefinitions: SoulverCore.LineCollectionReducer.CustomDefinitions {
    get
  }
  @objc deinit
}
public struct SalesTax : Swift.Equatable {
  public init(decimalValue: Foundation.Decimal)
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.SalesTax, b: SoulverCore.SalesTax) -> Swift.Bool
}
public struct Resolution {
  public let width: Foundation.Decimal
  public let height: Foundation.Decimal
}
public struct Percentage : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public init(value: Foundation.Decimal)
  public static func == (a: SoulverCore.Percentage, b: SoulverCore.Percentage) -> Swift.Bool
}
public struct Timestamp : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.Timestamp, b: SoulverCore.Timestamp) -> Swift.Bool
}
public typealias VariableName = Swift.String
public typealias VariableValue = Swift.String
public struct Variable : Swift.Codable {
  public enum VariableType : Swift.String, Swift.RawRepresentable, Swift.Codable {
    case undefined
    case local
    case global
    case lineReference
    case relativeLineReference
    case tag
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: SoulverCore.VariableName
  public let value: SoulverCore.VariableValue?
  public init(name: SoulverCore.VariableName, value: SoulverCore.VariableValue? = nil, type: SoulverCore.Variable.VariableType = .undefined)
  public var definition: SoulverCore.EvaluationResult?
  public var type: SoulverCore.Variable.VariableType
  public var isPhrase: Swift.Bool?
  public var declaringLineIndex: SoulverCore.LineIndex?
  public var relatedLineIndexes: Foundation.IndexSet?
  public var representedResults: [SoulverCore.EvaluationResult]?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension SoulverCore.Variable : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SoulverCore.Variable, rhs: SoulverCore.Variable) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Holiday {
  public init(day: Swift.Int, month: Swift.Int, year: Swift.Int)
  public let day: Swift.Int
  public let month: Swift.Int
  public let year: Swift.Int
  public var description: Swift.String?
}
extension SoulverCore.Holiday : Swift.Hashable, Swift.Equatable, Swift.Codable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.Holiday, b: SoulverCore.Holiday) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct Place {
  public enum PlaceType : Swift.Equatable, Swift.Hashable {
    case country(country: SoulverCore.Country)
    case city(city: SoulverCore.City)
    case airport(airport: SoulverCore.Airport)
    case timeZoneAbbreviation
    case unspecified
    public static func == (a: SoulverCore.Place.PlaceType, b: SoulverCore.Place.PlaceType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(name: Swift.String, aliases: [Swift.String]?, timeZone: Foundation.TimeZone, type: SoulverCore.Place.PlaceType = .unspecified)
  public let name: Swift.String
  public let aliases: [Swift.String]?
  public let timeZone: Foundation.TimeZone
  public let type: SoulverCore.Place.PlaceType
}
extension SoulverCore.Place : Swift.Hashable, Swift.Equatable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.Place, b: SoulverCore.Place) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.Place {
  public var city: Swift.String? {
    get
  }
  public var country: Swift.String? {
    get
  }
  public var gpsCoordinates: SoulverCore.GPSCoordinates? {
    get
  }
}
public struct ExpressionBeautificationOptions {
  public var quickOperators: Swift.Bool
  public var autoThousandsSeparators: Swift.Bool
  public var allowsOrphanedThousandsSeparators: Swift.Bool
  public var padStandardOperators: Swift.Bool
  public var padSlashOperatorWhereNecessary: Swift.Bool
  public var fancyTimes: Swift.Bool
  public var fancyMinus: Swift.Bool
  public var collapseSpaces: Swift.Bool
  public var formatsSlashCommentsWithSpaces: Swift.Bool
  public var useNonBreakingSpacesInMultiwordVariables: Swift.Bool
  public static var defaults: SoulverCore.ExpressionBeautificationOptions {
    get
  }
  public init()
}
public struct UnitRate {
  public let value: Foundation.Decimal
  public let ofUnit: SoulverCore.SCUnit?
  public let perUnit: SoulverCore.SCUnit
}
extension SoulverCore.UnitRate : Swift.Comparable {
  public static func < (lhs: SoulverCore.UnitRate, rhs: SoulverCore.UnitRate) -> Swift.Bool
  public static func == (a: SoulverCore.UnitRate, b: SoulverCore.UnitRate) -> Swift.Bool
}
extension SoulverCore.UnitRate : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.UnitExpression : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct Frametime : Swift.Equatable {
  public static func == (a: SoulverCore.Frametime, b: SoulverCore.Frametime) -> Swift.Bool
}
public class EvaluationResultFormatter {
  public init(customization: SoulverCore.EngineCustomization, formattingPreferences: SoulverCore.FormattingPreferences?)
  public func format(result: SoulverCore.EvaluationResult) -> SoulverCore.CalculationResult
  @objc deinit
}
public struct PercentageRate : Swift.Equatable {
  public static func == (a: SoulverCore.PercentageRate, b: SoulverCore.PercentageRate) -> Swift.Bool
}
infix operator ~ : AdditionPrecedence
@_hasMissingDesignatedInitializers public class LineCollectionFuser {
  public class func fusingTokensOfTypes(_ tokenTypeSet: SoulverCore.TokenTypeSet, from lineCollection: SoulverCore.LineCollection) -> SoulverCore.LineCollection
  @objc deinit
}
final public class LineCollection {
  public typealias EvaluatedLinesHandler = (_ evaluatedIndexes: Foundation.IndexSet) -> Swift.Void
  final public var customization: SoulverCore.EngineCustomization {
    get
  }
  final public var lineSheet: SoulverCore.LineSheet {
    get
    set
  }
  final public var variableList: SoulverCore.VariableList? {
    get
    set
  }
  final public var defaultLineFormattingPreferences: SoulverCore.FormattingPreferences? {
    get
    set
  }
  final public var expressionBeautificationOptions: SoulverCore.ExpressionBeautificationOptions? {
    get
    set
  }
  final public var commentingOptions: SoulverCore.CommentingOptions {
    get
    set
  }
  public init(customization: SoulverCore.EngineCustomization)
  final public var deepCopy: SoulverCore.LineCollection {
    get
  }
  final public func beginChanges()
  final public func endChangesWith(evaluationHandler: SoulverCore.LineCollection.EvaluatedLinesHandler?, dependenciesHandler: SoulverCore.LineCollection.EvaluatedLinesHandler?)
  @discardableResult
  final public func addLine(_ expression: Swift.String = "") -> SoulverCore.Line
  final public func setLinesWithExpressions(_ expressions: [SoulverCore.RawExpression])
  final public func insertLineBelow(lineIndex: SoulverCore.LineIndex, with expression: Swift.String)
  final public func insertLineAt(lineIndex: SoulverCore.LineIndex, with expression: Swift.String)
  final public func insert(line: SoulverCore.Line, at lineIndex: SoulverCore.LineIndex)
  final public func moveLineAt(lineIndex: SoulverCore.LineIndex, toLineIndex: SoulverCore.LineIndex)
  final public func removeLineAt(lineIndex: SoulverCore.LineIndex)
  final public func replaceLineAt(lineIndex: SoulverCore.LineIndex, with newLine: SoulverCore.Line)
  final public subscript(index: SoulverCore.LineIndex) -> SoulverCore.Line {
    get
    set(newValue)
  }
  final public subscript(safe index: SoulverCore.LineIndex) -> SoulverCore.Line? {
    get
  }
  final public func setExpression(expression: Swift.String, forLineAt index: SoulverCore.LineIndex)
  final public func setFormatting(formattingPreferences: SoulverCore.FormattingPreferences)
  final public func setFormatting(formattingPreferences: SoulverCore.FormattingPreferences?, forLineAt index: SoulverCore.LineIndex)
  final public func setAlignment(alignment: SoulverCore.Line.ExpressionAlignment, forLineAt index: SoulverCore.LineIndex)
  final public func setHighlight(highlight: SoulverCore.Line.HighlightColor?, forLineAt index: SoulverCore.LineIndex)
  final public func setAttribution(attribution: Swift.String?, forLineAt index: SoulverCore.LineIndex)
  final public func setBehaviour(behaviour: SoulverCore.Line.CalculationBehaviour, forLineAt index: SoulverCore.LineIndex)
  final public func cancelPendingAnswer(forLineAt lineIndex: SoulverCore.LineIndex)
  final public func evaluateAll()
  @discardableResult
  final public func evaluateLinesAt(indexes: Foundation.IndexSet, dependenciesUpdatedHandler: SoulverCore.LineCollection.EvaluatedLinesHandler? = nil) -> Foundation.IndexSet
  @discardableResult
  final public func makeReferenceForLineAt(lineIndex: SoulverCore.LineIndex) -> SoulverCore.LineReference
  final public func clearReferenceForLineAt(lineIndex: SoulverCore.LineIndex)
  @discardableResult
  final public func observeEvaluationWith(handler: @escaping SoulverCore.LineCollection.EvaluatedLinesHandler) -> SoulverCore.LineCollection.LineCollectionObserverToken
  final public func remove(observer: SoulverCore.LineCollection.LineCollectionObserverToken)
  final public var includeVariableReferencingPreviousLine: Swift.Bool {
    get
    set
  }
  final public var includeVariablesReferencingLineNumbers: Swift.Bool {
    get
    set
  }
  final public var rawStringVariableDefinitions: Swift.Bool {
    get
    set
  }
  final public var unitDeclarations: Swift.Bool {
    get
    set
  }
  final public var remoteQueries: Swift.Bool {
    get
    set
  }
  final public var tripPlanning: Swift.Bool {
    get
    set
  }
  final public var generateVariablesFromLabels: Swift.Bool {
    get
    set
  }
  final public func calculateQuickStatistic(statisticType: SoulverCore.StatisticType, limitToIndexes: Foundation.IndexSet? = nil, ignoreVariableDeclaration: Swift.Bool = true, ignoreReferencedLines: Swift.Bool = true) -> SoulverCore.CalculationResult?
  final public var quickSum: SoulverCore.CalculationResult? {
    get
  }
  final public var quickAverage: SoulverCore.CalculationResult? {
    get
  }
  final public var quickCount: SoulverCore.CalculationResult? {
    get
  }
  final public func quickSumOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  final public func quickAverageOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  final public func quickCountOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  @discardableResult
  final public func convertToLocale(_ toLocale: Foundation.Locale) -> Swift.Bool
  final public func set(customization: SoulverCore.EngineCustomization)
  final public func performChanges(performBlock: ((SoulverCore.LineCollection) -> Swift.Void)) -> SoulverCore.LineCollection.LineCollectionStateTicket
  @discardableResult
  final public func revertToStateWith(ticket: SoulverCore.LineCollection.LineCollectionStateTicket) -> SoulverCore.LineSheetDelta?
  final public func clearStates()
  final public var lineCount: Swift.Int {
    get
  }
  final public func isValidIndex(_ lineIndex: SoulverCore.LineIndex) -> Swift.Bool
  final public func areValidIndexes(_ indexes: Foundation.IndexSet) -> Swift.Bool
  final public var allIndexes: Foundation.IndexSet {
    get
  }
  final public var lastIndex: Swift.Int {
    get
  }
  final public var firstIndex: Swift.Int {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var lines: [SoulverCore.Line] {
    get
  }
  final public func linesAtIndexes(indexes: Foundation.IndexSet) -> [SoulverCore.Line]
  final public func variableStateOnLine(_ lineIndex: SoulverCore.LineIndex) -> SoulverCore.VariableList
  final public var finalVariableState: SoulverCore.VariableList {
    get
  }
  final public func resultsAsVariableWith(title: Swift.String, statistic: SoulverCore.StatisticType?) -> SoulverCore.Variable
  final public func tokenFor(tokenIndexPath: SoulverCore.TokenIndexPath) -> SoulverCore.Token?
  final public func indexPathFor(token: SoulverCore.Token, onLineAt lineIndex: SoulverCore.LineIndex) -> SoulverCore.TokenIndexPath?
  final public func isValidLineReference(UID: SoulverCore.UID, onLineAt lineIndex: SoulverCore.LineIndex) -> Swift.Bool
  final public func lineForLineReference(lineReference: SoulverCore.LineReference) -> SoulverCore.Line?
  final public func lineFor(_ lineReferenceVariable: SoulverCore.Variable) -> SoulverCore.Line?
  final public func formattedDefinitionOf(inlineVariable: SoulverCore.Variable) -> Swift.String?
  @discardableResult
  final public func replaceOccurancesInExpressions(replacements: [Swift.String : Swift.String], forTypes: Swift.Set<SoulverCore.TokenType>? = nil) -> Foundation.IndexSet
  final public func unformattedResultFor(lineIndex: SoulverCore.LineIndex) -> Swift.String
  final public func append(otherLineCollection: SoulverCore.LineCollection)
  final public var subsheetCount: Swift.Int {
    get
  }
  @discardableResult
  final public func addSubsheet(evaluator: SoulverCore.Subsheet.SubsheetEvaluatorType = .soulverCore, canReferenceVariablesOutsideBody: Swift.Bool = true) -> SoulverCore.LineReference
  final public func subsheetWith(reference: SoulverCore.LineReference) -> SoulverCore.Subsheet?
  final public func set(content lineSheet: SoulverCore.LineSheet, forSubsheetWith reference: SoulverCore.LineReference)
  @objc deinit
}
extension SoulverCore.LineCollection : Swift.CustomDebugStringConvertible {
  public typealias MultiLineText = Swift.String
  final public class func textViewReadyLineCollectionWith(customization: SoulverCore.EngineCustomization) -> SoulverCore.LineCollection
  convenience public init(multiLineText: SoulverCore.LineCollection.MultiLineText, customization: SoulverCore.EngineCustomization? = nil)
  public static var basic: SoulverCore.LineCollection {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.LineCollection {
  public typealias LineCollectionStateTicket = Swift.String
  @_hasMissingDesignatedInitializers public class LineCollectionObserverToken : Swift.Hashable, Swift.Equatable {
    public static func == (lhs: SoulverCore.LineCollection.LineCollectionObserverToken, rhs: SoulverCore.LineCollection.LineCollectionObserverToken) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SoulverCore.LineCollection {
  final public var indexesOfTimeDependentLines: Foundation.IndexSet {
    get
  }
  final public func indexesOfLinesDependentOn(variables: [SoulverCore.Variable]) -> Foundation.IndexSet
  final public var indexesOfPendingLines: Foundation.IndexSet {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionIterator : Swift.IteratorProtocol {
  public typealias Element = SoulverCore.Line
  public func next() -> SoulverCore.Line?
  @objc deinit
}
extension SoulverCore.LineCollection : Swift.Sequence {
  final public func makeIterator() -> SoulverCore.LineCollectionIterator
  public typealias Element = SoulverCore.LineCollectionIterator.Element
  public typealias Iterator = SoulverCore.LineCollectionIterator
}
extension SoulverCore.LineCollection {
  final public var text: SoulverCore.LineCollection.MultiLineText {
    get
  }
}
public struct UnitExpression {
  public let value: Foundation.Decimal
  public let unit: SoulverCore.SCUnit
  public func convertedTo(unit identifier: SoulverCore.UnitIdentifier) -> SoulverCore.UnitExpression?
}
extension SoulverCore.UnitExpression {
  public static func with(unit: SoulverCore.UnitIdentifier, and value: Foundation.Decimal) -> SoulverCore.UnitExpression
}
extension SoulverCore.UnitExpression : Swift.Comparable {
  public static func == (lhs: SoulverCore.UnitExpression, rhs: SoulverCore.UnitExpression) -> Swift.Bool
  public static func < (lhs: SoulverCore.UnitExpression, rhs: SoulverCore.UnitExpression) -> Swift.Bool
}
extension SoulverCore.UnitExpression : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.SCUnit {
  public var prefersZeroDP: Swift.Bool {
    get
  }
  public var prefersThreeDP: Swift.Bool {
    get
  }
  public var isCryptoCurrency: Swift.Bool {
    get
  }
}
public struct EngineCustomization : Swift.Equatable, Swift.Hashable {
  public let locale: Foundation.Locale
  public let calendar: Foundation.Calendar
  public var timeZone: Foundation.TimeZone {
    get
  }
  public var customUnits: [SoulverCore.CustomUnit]
  public var currencyRateProvider: (any SoulverCore.CurrencyRateProvider)?
  public var weatherDataProvider: (any SoulverCore.WeatherDataProvider)?
  public enum CurrencySymbolSettings : Swift.Equatable, Swift.Hashable {
    case automatic
    case manualWith(symbols: [SoulverCore.UnitSymbolReplacement])
    public static func == (a: SoulverCore.EngineCustomization.CurrencySymbolSettings, b: SoulverCore.EngineCustomization.CurrencySymbolSettings) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var currencySymbolSettings: SoulverCore.EngineCustomization.CurrencySymbolSettings
  public var customPlaces: [SoulverCore.Place]
  public var customFunctions: [SoulverCore.CustomFunction]
  public var holidays: [SoulverCore.Holiday]
  public var unitSystem: SoulverCore.UnitMeasurementSystem
  public var baseFontSize: Foundation.Decimal
  public var featureFlags: SoulverCore.EngineFeatureFlags
  public init(locale: Foundation.Locale, calendar: Foundation.Calendar? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: SoulverCore.EngineCustomization, rhs: SoulverCore.EngineCustomization) -> Swift.Bool
  public static var standard: SoulverCore.EngineCustomization {
    get
  }
  public static var soulver: SoulverCore.EngineCustomization {
    get
  }
  public func convertTo(locale: Foundation.Locale) -> SoulverCore.EngineCustomization
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.EngineCustomization {
  public static func standardWith(locale: Foundation.Locale) -> SoulverCore.EngineCustomization
  public func isOperator(text: Swift.String) -> Swift.Bool
  public func isClassicFunction(text: Swift.String) -> Swift.Bool
  public func longFormNameFor(unitIdentifier: SoulverCore.UnitIdentifier) -> Swift.String?
  public func symbolFor(unitIdentifier: SoulverCore.UnitIdentifier) -> Swift.String?
  @available(*, deprecated, message: "Use `EngineCustomization/currencySymbolSettings` instead.")
  public var customSymbols: [SoulverCore.UnitSymbolReplacement] {
    get
    set
  }
}
extension SoulverCore.EngineCustomization : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct CurrencyRateRequest {
  public let unitIdentifier: SoulverCore.UnitIdentifier
  public let currencyCode: SoulverCore.CurrencyCode
  public let baseCurrencyCode: Swift.String
  public let baseCurrencyQuantity: Swift.Double
}
public protocol CurrencyRateProvider : AnyObject {
  func rateFor(request: SoulverCore.CurrencyRateRequest) -> Foundation.Decimal?
}
public struct WeatherDataRequest {
  public let function: SoulverCore.FunctionIdentifier
  public let location: SoulverCore.Place
  public let date: Foundation.Date?
}
public protocol WeatherDataProvider : AnyObject {
  #if compiler(>=5.3) && $AsyncAwait
  func dataFor(request: SoulverCore.WeatherDataRequest) async throws -> SoulverCore.EvaluationResult?
  #endif
}
public typealias PrivateUnicodeSymbol = Swift.String
@_hasMissingDesignatedInitializers public class SingleCharacterUIDGenerator {
  public class func isUID(symbol: SoulverCore.PrivateUnicodeSymbol) -> Swift.Bool
  public class func parameterIndexFor(UID: SoulverCore.PrivateUnicodeSymbol) -> Swift.Int?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class StaticResouces {
  public static var localizedCountries: [SoulverCore.Country] {
    get
  }
  public static var localizedCities: [SoulverCore.City] {
    get
  }
  public static var localizedStates: [SoulverCore.Country] {
    get
  }
  @objc deinit
}
public struct UnitSymbolReplacement : Swift.Equatable, Swift.Hashable, Swift.Codable {
  public enum UnitSymbolReplacementPosition : Swift.String, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable {
    case before
    case beforeWithSpace
    case after
    case afterWithSpace
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition]
    public typealias RawValue = Swift.String
    public static var allCases: [SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public let originalSymbol: Swift.String
  public let replacementSymbol: Swift.String
  public let position: SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition
  public init(original: Swift.String, replacement: Swift.String, position: SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition = .before)
  public static func standardCustomSymbolsFor(locale: Foundation.Locale) -> [SoulverCore.UnitSymbolReplacement]
  public static func == (a: SoulverCore.UnitSymbolReplacement, b: SoulverCore.UnitSymbolReplacement) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct DegreesMinutesSeconds : Swift.Equatable {
  public enum CardinalDirection : Swift.String, Swift.CaseIterable, Swift.Equatable {
    case north
    case south
    case east
    case west
    public init?(rawValue: Swift.String)
    public typealias AllCases = [SoulverCore.DegreesMinutesSeconds.CardinalDirection]
    public typealias RawValue = Swift.String
    public static var allCases: [SoulverCore.DegreesMinutesSeconds.CardinalDirection] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public let degrees: Foundation.Decimal
  public let minutes: Foundation.Decimal
  public let seconds: Foundation.Decimal
  public let cardinalDirection: SoulverCore.DegreesMinutesSeconds.CardinalDirection?
  public static func == (a: SoulverCore.DegreesMinutesSeconds, b: SoulverCore.DegreesMinutesSeconds) -> Swift.Bool
}
public enum MisplacedThousandsSeparatorBehavior {
  case allow
  case disallow
  case interpretAsDecimalPoint
  public static func == (a: SoulverCore.MisplacedThousandsSeparatorBehavior, b: SoulverCore.MisplacedThousandsSeparatorBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class ECBCurrencyRateProvider : SoulverCore.CurrencyRateProvider {
  public init()
  @available(*, renamed: "updateRates()")
  public func updateRates(completionHandler: @escaping ((_ success: Swift.Bool) -> Swift.Void))
  #if compiler(>=5.3) && $AsyncAwait
  public func updateRates() async -> Swift.Bool
  #endif
  public func rateFor(request: SoulverCore.CurrencyRateRequest) -> Foundation.Decimal?
  @objc deinit
}
public struct FormattingPreferences : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public static var maximumDp: Swift.Int
  public var dp: Swift.Int
  public var thousandsSeparatorDisabled: Swift.Bool
  public var currencyFormattingPreferences: SoulverCore.CurrencyFormattingPreferences
  public var notationPreferences: SoulverCore.NotationPreferences
  public var referencesTakeFormattedValue: Swift.Bool
  public var resultConversionBehavior: SoulverCore.ResultConversionBehavior
  public init()
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: SoulverCore.FormattingPreferences, b: SoulverCore.FormattingPreferences) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CurrencyFormattingPreferences : Swift.Equatable, Swift.Hashable, Swift.Codable {
  public var useCurrencySymbols: Swift.Bool
  public var roundResults: Swift.Bool
  public var showTrailingZeros: Swift.Bool
  public static var standard: SoulverCore.CurrencyFormattingPreferences
  public static var disabled: SoulverCore.CurrencyFormattingPreferences
  public static func == (a: SoulverCore.CurrencyFormattingPreferences, b: SoulverCore.CurrencyFormattingPreferences) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NotationPreferences : Swift.Equatable, Swift.Hashable {
  public enum NotationStyle {
    case auto
    case on
    case off
    public static func == (a: SoulverCore.NotationPreferences.NotationStyle, b: SoulverCore.NotationPreferences.NotationStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var notationStyle: SoulverCore.NotationPreferences.NotationStyle
  public var upperNotationThreshold: SoulverCore.SIThreshold
  public init(notationStyle: SoulverCore.NotationPreferences.NotationStyle, upperNotationThreshold: SoulverCore.SIThreshold = .trillion)
  public static var off: SoulverCore.NotationPreferences {
    get
  }
  public static func == (a: SoulverCore.NotationPreferences, b: SoulverCore.NotationPreferences) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ResultConversionRule : Swift.Equatable, Swift.Hashable {
  case tokenOf(type: SoulverCore.TokenType, convertToType: SoulverCore.TokenType)
  case unitExpressionOf(unitType: SoulverCore.UnitType, convertToUnit: SoulverCore.UnitIdentifier)
  case unitExpressionWith(identifier: SoulverCore.UnitIdentifier, convertToUnit: SoulverCore.UnitIdentifier)
  case convertToTimespanUnitExpressionWith(identifier: SoulverCore.UnitIdentifier)
  case convertToFeetAndInchesUnitExpressionWith(identifier: SoulverCore.UnitIdentifier)
  case timeWithTimezone(convertToTimezone: Foundation.TimeZone)
  public static func == (a: SoulverCore.ResultConversionRule, b: SoulverCore.ResultConversionRule) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ResultConversionBehavior : Swift.Equatable, Swift.Hashable {
  case none
  case automatic
  case customRules([SoulverCore.ResultConversionRule])
  public static func == (a: SoulverCore.ResultConversionBehavior, b: SoulverCore.ResultConversionBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.FormattingPreferences {
  public var currencyFormattingDisabled: Swift.Bool {
    get
    set
  }
  public var fractionizeWherePossible: Swift.Bool {
    get
    set
  }
}
public struct Country {
  public let name: Swift.String
  public let capital: Swift.String
  public let capitalCityTimezoneID: Swift.String?
  public var timeZone: Foundation.TimeZone? {
    get
  }
}
extension SoulverCore.Country : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public static func == (a: SoulverCore.Country, b: SoulverCore.Country) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct City {
  public let identifier: Swift.String
  public let name: Swift.String
  public let country: Swift.String?
  public let longitude: Swift.String?
  public let latitude: Swift.String?
  public let timezone_id: Swift.String
  public var timeZone: Foundation.TimeZone? {
    get
  }
}
extension SoulverCore.City : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public static func == (a: SoulverCore.City, b: SoulverCore.City) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class TokenList {
  final public var tokens: [SoulverCore.Token]
  @objc deinit
}
extension SoulverCore.TokenList : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: SoulverCore.TokenList, rhs: SoulverCore.TokenList) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.TokenList : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.TokenList {
  final public subscript(index: Swift.Int) -> SoulverCore.Token {
    get
    set(newValue)
  }
  final public var count: Swift.Int {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public func typePrecheck(_ type: SoulverCore.TokenType) -> Swift.Bool
  final public func typesPrecheck(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  final public func allTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  final public func onlyTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  final public func anyTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  final public func firstToken(ofType: SoulverCore.TokenType) -> SoulverCore.Token?
  final public func lastToken(ofType: SoulverCore.TokenType) -> SoulverCore.Token?
  final public func lastToken(ofTypes: SoulverCore.TokenTypeSet) -> SoulverCore.Token?
  final public func tokenBefore(_ token: SoulverCore.Token, mustBe type: SoulverCore.TokenType, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  final public func tokenAfter(_ token: SoulverCore.Token, mustBe type: SoulverCore.TokenType, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  final public func tokensOfType(_ tokenType: SoulverCore.TokenType) -> [SoulverCore.Token]
  final public func tokensOfTypes(_ tokenTypeSet: SoulverCore.TokenTypeSet) -> [SoulverCore.Token]
  final public func allTokensOfType(_ tokenType: SoulverCore.TokenType, excludingTokensWhereParentIsIn parentTokenTypes: SoulverCore.TokenTypeSet = TokenTypeSet(types: [])) -> [SoulverCore.Token]
  final public func scanForTokenWithTypes(_ tokenTypes: SoulverCore.TokenTypeSet, ignoreParentsWithTypes parentTypes: SoulverCore.TokenTypeSet? = nil) -> Swift.Bool
  final public func enumerateSublists(reversed: Swift.Bool, includeSelf: Swift.Bool, enumerationBlock: (_ subList: SoulverCore.TokenList, _ parent: SoulverCore.Token?) -> Swift.Void)
  final public func findParentOf(childToken: SoulverCore.Token, highestLevelParent: Swift.Bool = false, inRange limitToRange: Swift.ClosedRange<Swift.Int>? = nil) -> SoulverCore.Token?
  final public func tokenFor(tokenIndex: SoulverCore.TokenIndex) -> SoulverCore.Token?
  final public func tokenIndexFor(token: SoulverCore.Token) -> SoulverCore.TokenIndex?
  final public func tokenFor(characterIndex: Swift.Int, ignoreWhitespace: Swift.Bool = true, endOfLineReturnsLastToken: Swift.Bool = false) -> SoulverCore.Token?
  public typealias TokenListEnumerationBlock = (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Void
  final public func enumerateAllTokensOfType(_ type: SoulverCore.TokenType, reversed: Swift.Bool = true, enumerationBlock: (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Void)
}
public class ResultCollection {
  final public let results: [SoulverCore.CalculationResult]
  final public let customization: SoulverCore.EngineCustomization
  final public let formattingPreferences: SoulverCore.FormattingPreferences?
  public init(results: [SoulverCore.CalculationResult], customization: SoulverCore.EngineCustomization, formattingPreferences: SoulverCore.FormattingPreferences? = nil)
  public var sum: SoulverCore.CalculationResult? {
    get
  }
  public var average: SoulverCore.CalculationResult? {
    get
  }
  public var count: SoulverCore.CalculationResult? {
    get
  }
  public var resultsAreEmpty: Swift.Bool {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LineCollectionTrimmer {
  public class func trimmingTokensOfTypes(_ tokenTypeSet: SoulverCore.TokenTypeSet, from lineCollection: SoulverCore.LineCollection) -> SoulverCore.LineCollection
  @objc deinit
}
extension Swift.String {
  public func find<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current) -> T.DataType? where T : SoulverCore.DataFromTokenParser
  public func find<T, U>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, locale: Foundation.Locale = .current) -> (T.DataType, U.DataType)? where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser
  public func find<T, U, Y>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<Y>, locale: Foundation.Locale = .current) -> (T.DataType, U.DataType, Y.DataType)? where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, Y : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, locale: Foundation.Locale = .current) -> (T.DataType, U.DataType, V.DataType, W.DataType)? where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W, X>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, _ entity5: SoulverCore.DataPoint<X>, locale: Foundation.Locale = .current) -> (T.DataType, U.DataType, V.DataType, W.DataType, X.DataType)? where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser, X : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W, X, Y>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, _ entity5: SoulverCore.DataPoint<X>, _ entity6: SoulverCore.DataPoint<Y>, locale: Foundation.Locale = .current) -> (T.DataType, U.DataType, V.DataType, W.DataType, X.DataType, Y.DataType)? where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser, X : SoulverCore.DataFromTokenParser, Y : SoulverCore.DataFromTokenParser
  public func replacingAll<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: ((T.DataType) -> Swift.String?)) -> Swift.String where T : SoulverCore.DataFromTokenParser
  public func replacingFirst<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: ((T.DataType) -> Swift.String?)) -> Swift.String where T : SoulverCore.DataFromTokenParser
}
extension Swift.String {
  public var dateValue: Foundation.Date? {
    get
  }
}
public protocol DataFromTokenParser {
  associatedtype DataType
  func parseDataFrom(token: SoulverCore.Token) -> Self.DataType?
}
public struct DataPoint<T> where T : SoulverCore.DataFromTokenParser {
  public init(parser: T)
}
public struct CustomFunctionParameter {
  public let subsheet: SoulverCore.Subsheet
  public let matchedToken: SoulverCore.Token
}
public class CustomFunctionDefinitionUtility {
  public init(customization: SoulverCore.EngineCustomization)
  public func parametersIn(customFunctionDefinition: SoulverCore.RawExpression) -> [SoulverCore.CustomFunctionParameter]?
  public func prototypeExpressionFrom(customFunctionDefinition: SoulverCore.RawExpression) -> SoulverCore.PrototypeExpression?
  public func customFunctionFrom(customFunctionDefinition: SoulverCore.RawExpression, implementationBody: SoulverCore.LineSheet) -> SoulverCore.CustomFunction?
  @objc deinit
}
public enum UnitMeasurementSystem : Swift.String, Swift.RawRepresentable, Swift.Equatable, Swift.CaseIterable {
  case customaryUS
  case imperial
  case metric
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.UnitMeasurementSystem]
  public typealias RawValue = Swift.String
  public static var allCases: [SoulverCore.UnitMeasurementSystem] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct Fraction : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public let unitValue: SoulverCore.SCUnit?
  public static func == (a: SoulverCore.Fraction, b: SoulverCore.Fraction) -> Swift.Bool
}
extension SoulverCore.TimezoneCodeCorrectionBehavior : Swift.Equatable {}
extension SoulverCore.TimezoneCodeCorrectionBehavior : Swift.Hashable {}
extension SoulverCore.FunctionIdentifier : Swift.Equatable {}
extension SoulverCore.FunctionIdentifier : Swift.Hashable {}
extension SoulverCore.Datestamp.DatestampType : Swift.Equatable {}
extension SoulverCore.Datestamp.DatestampType : Swift.Hashable {}
extension SoulverCore.Line.CalculationBehaviour : Swift.Equatable {}
extension SoulverCore.Line.CalculationBehaviour : Swift.Hashable {}
extension SoulverCore.Line.CalculationBehaviour : Swift.RawRepresentable {}
extension SoulverCore.Line.ExpressionAlignment : Swift.Equatable {}
extension SoulverCore.Line.ExpressionAlignment : Swift.Hashable {}
extension SoulverCore.Line.ExpressionAlignment : Swift.RawRepresentable {}
extension SoulverCore.Line.HighlightColor : Swift.Equatable {}
extension SoulverCore.Line.HighlightColor : Swift.Hashable {}
extension SoulverCore.Line.ApparentLineType : Swift.Equatable {}
extension SoulverCore.Line.ApparentLineType : Swift.Hashable {}
extension SoulverCore.TokenType : Swift.Equatable {}
extension SoulverCore.TokenType : Swift.Hashable {}
extension SoulverCore.TokenSubType : Swift.Equatable {}
extension SoulverCore.TokenSubType : Swift.Hashable {}
extension SoulverCore.EvaluationError : Swift.Equatable {}
extension SoulverCore.EvaluationError : Swift.Hashable {}
extension SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy : Swift.Equatable {}
extension SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy : Swift.Hashable {}
extension SoulverCore.LineCollectionEnumerator.ResultFormatting : Swift.Equatable {}
extension SoulverCore.LineCollectionEnumerator.ResultFormatting : Swift.Hashable {}
extension SoulverCore.UnitType : Swift.Equatable {}
extension SoulverCore.UnitType : Swift.Hashable {}
extension SoulverCore.UnitType : Swift.RawRepresentable {}
extension SoulverCore.UnitIdentifier : Swift.Equatable {}
extension SoulverCore.UnitIdentifier : Swift.Hashable {}
extension SoulverCore.StatisticType : Swift.Hashable {}
extension SoulverCore.Subsheet.SubsheetEvaluatorType : Swift.Equatable {}
extension SoulverCore.Subsheet.SubsheetEvaluatorType : Swift.Hashable {}
extension SoulverCore.Subsheet.SubsheetEvaluatorType : Swift.RawRepresentable {}
extension SoulverCore.SIThreshold : Swift.Equatable {}
extension SoulverCore.SIThreshold : Swift.Hashable {}
extension SoulverCore.SIThreshold : Swift.RawRepresentable {}
extension SoulverCore.Variable.VariableType : Swift.Equatable {}
extension SoulverCore.Variable.VariableType : Swift.Hashable {}
extension SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition : Swift.Equatable {}
extension SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition : Swift.Hashable {}
extension SoulverCore.DegreesMinutesSeconds.CardinalDirection : Swift.Hashable {}
extension SoulverCore.DegreesMinutesSeconds.CardinalDirection : Swift.RawRepresentable {}
extension SoulverCore.MisplacedThousandsSeparatorBehavior : Swift.Equatable {}
extension SoulverCore.MisplacedThousandsSeparatorBehavior : Swift.Hashable {}
extension SoulverCore.NotationPreferences.NotationStyle : Swift.Equatable {}
extension SoulverCore.NotationPreferences.NotationStyle : Swift.Hashable {}
extension SoulverCore.UnitMeasurementSystem : Swift.Hashable {}
